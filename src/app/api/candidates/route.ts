//Generated by WriteToModelsRouteApi - models route next 13 with SQL
import CandidateModel, { Candidate } from "@/models/CandidateModel";
import { FindOptions, QueryTypes, Transaction } from "sequelize";
import {
  checkDuplicateCombinations,
  getSort,
  parseParams,
  reduceResult,
  removeDuplicates,
  returnJSONResponse,
} from "@/utils/utils";
import sequelize from "@/config/db";
import handleSequelizeError from "@/utils/errorHandling";
import { Op } from "sequelize";
import {
  CandidateDeletePayload,
  CandidateFormUpdatePayload,
  CandidateFormikShape,
  CandidateSearchParams,
  CandidateUpdatePayload,
} from "@/interfaces/CandidateInterfaces";
import { NextResponse } from "next/server";
import { DEFAULT_LIMIT } from "@/utils/constants";
import {
  COLUMNS,
  DEFAULT_SORT_BY,
  PRIMARY_KEY,
  TABLE_NAME,
  UNIQUE_FIELDS,
} from "@/utils/constants/CandidateConstants";
import { CandidateSchema } from "@/schema/CandidateSchema";
import {
  addCursorFilterToQuery,
  appendFieldsToSQL,
  getColumnKeyByDbName,
  getCursorString,
  getDatabaseFieldName,
  getMappedKeys,
  getSortedValue,
  processFields,
  resetSQL,
} from "@/utils/api/utils";
import clsJoin from "@/utils/clsJoin";
import clsSQL from "@/utils/clsSQL";
//Generated by GetAllCreateSimpleModelFromRoute
//Generated by GetCreateSimpleModelFromRoute - GetCreateSimpleModelFromRoute
import { createCandidateStatus } from "@/utils/api/CandidateStatusLibs";

import {
  createCandidate,
  deleteCandidates,
  updateCandidate,
} from "@/utils/api/CandidateLibs";

const ModelObject = Candidate;

//Generated by GeneratefindOptions
const findOptions: FindOptions<typeof Candidate> = {
  //Generated by GenerateIncludeOption
  include: [],
  //Generated by GenerateAttributesOption
  attributes: [
    //Generated by GetAllModelAttributesBySeqModel
    "candidateName",
    "source",
    "candidateState",
    "providerID",
    "providerState",
    "providerOffice",
    "providerSource",
    "providerType",
    "providerContactName",
    "providerEmail",
    "providerContactNumber",
    "email",
    "employer",
    "employerOffice",
    "employerState",
    "employerCandidateID",
    "employerCandidateOwner",
    "groupSite",
    "division",
    "wageSubsidyAmount",
    "benchmarkHours",
    "startDate",
    "stage",
    "outcomeReminder",
    "payslipStatus",
    "priority",
    "placementSent",
    "placementStatus",
    "archive",
    "invoiced",
    "invoiceNumber",
    "enquiryDate",
    "enquiryType",
    "wSAgreement",
    "wSSchedule",
    "notes",
    "id",
    "createdAt",
    "updatedAt",
  ],
};

//Generated by GetGetmodelsqlNext13 - getModelSQL Next 13
function getCandidateSQL(
  query: Partial<CandidateSearchParams>,
  dontFilter: boolean = false
) {
  const candidateAttributes = getMappedKeys(COLUMNS);

  const simpleOnly = query["simpleOnly"];
  const cursor = query["cursor"];
  const limit = query["limit"] || DEFAULT_LIMIT;

  const sort = getSortedValue(
    query["sort"]
      ? `${query["sort"].includes("-") ? "-" : ""}${getDatabaseFieldName(
          query["sort"],
          COLUMNS
        )}`
      : undefined,
    candidateAttributes,
    DEFAULT_SORT_BY
  );

  //Remove the - from the sort parameter
  const sortField = sort.includes("-") ? sort.substring(1) : sort;

  //Declare the variables
  const table = TABLE_NAME;
  const fields: ([string, string] | string)[] =
    //Generated by GenerateSQLFieldList
    [
      ["candidate_name", "candidateName"],
      "source",
      ["candidate_state", "candidateState"],
      ["provider_id", "providerID"],
      ["provider_state", "providerState"],
      ["provider_office", "providerOffice"],
      ["provider_source", "providerSource"],
      ["provider_type", "providerType"],
      ["provider_contact_name", "providerContactName"],
      ["provider_email", "providerEmail"],
      ["provider_contact_number", "providerContactNumber"],
      "email",
      "employer",
      ["employer_office", "employerOffice"],
      ["employer_state", "employerState"],
      ["employer_candidate_id", "employerCandidateID"],
      ["employer_candidate_owner", "employerCandidateOwner"],
      ["group_site", "groupSite"],
      "division",
      ["wage_subsidy_amount", "wageSubsidyAmount"],
      ["benchmark_hours", "benchmarkHours"],
      ["start_date", "startDate"],
      "stage",
      ["outcome_reminder", "outcomeReminder"],
      ["payslip_status", "payslipStatus"],
      "priority",
      ["placement_sent", "placementSent"],
      ["placement_status", "placementStatus"],
      ["360archive", "archive"],
      ["360invoiced", "invoiced"],
      ["360_invoice_number", "invoiceNumber"],
      ["360_enquiry_date", "enquiryDate"],
      ["360_enquiry_type", "enquiryType"],
      ["wsagreement", "wSAgreement"],
      ["wsschedule", "wSSchedule"],
      ["360notes", "notes"],
      "id",
    ];

  //This will be used to store the fields to be used from the joins
  const joinFields: string[] = [];

  //This will be used to store the replacements needed
  let replacements: Record<string, string> = {};

  const sql = new clsSQL();
  sql.source = table;

  const filters: string[] = [];

  if (!simpleOnly || simpleOnly !== "true") {
    //Generated by GenerateSeqModelFilters
    //Generated by GetLikeFilters - LIKE Template
    const q = query.q as string;

    if (q && !dontFilter) {
      const fields: string[] = ["candidate_name"];
      replacements["q"] = `%${q}%`;
      filters.push(
        `(${fields
          .map((field) => `(${TABLE_NAME}.${field} LIKE :q)`)
          .join(" OR ")})`
      );
    }
  }

  /* INSERT JOINS HERE */
  //Generated by GetAllSQLRightJoinSnippets
  //Generated by GetSQLRightJoinSnippetFromRelationship - GetSQLRightJoinSnippetFromRelationship
  let {
    sql: provider_SQL,
    fieldAliases: provider_fieldAliases,
    replacements: provider_replacements,
    subqueryAlias: provider_subqueryAlias,
    modelName: provider_modelName,
    filtered: provider_filtered,
  } = getProviderSQL(query, dontFilter);

  replacements = { ...replacements, ...provider_replacements };

  provider_fieldAliases.forEach((field) => {
    joinFields.push(`${provider_subqueryAlias}.${field}`);
  });

  const providerJoin = new clsJoin(
    provider_SQL.sql(),
    "provider_id",
    `\`${provider_modelName}.id\``, //`provider.id`
    provider_subqueryAlias, //tempProviders
    "INNER"
  );

  if (provider_filtered) {
    sql.joins.push(providerJoin);
  }
  //Generated by GetAllSQLLeftJoinSnippets
  //Generated by GetSQLLeftJoinSnippetFromRelationship - GetSQLLeftJoinSnippetFromRelationship
  let {
    sql: candidateStatus_SQL,
    fieldAliases: candidateStatus_fieldAliases,
    replacements: candidateStatus_replacements,
    subqueryAlias: candidateStatus_subqueryAlias,
    modelName: candidateStatus_modelName,
    filtered: candidateStatus_filtered,
  } = getCandidateStatusSQL(query, dontFilter);

  replacements = { ...replacements, ...candidateStatus_replacements };

  candidateStatus_fieldAliases.forEach((field) => {
    joinFields.push(`${candidateStatus_subqueryAlias}.${field}`);
  });

  const candidateStatusJoin = new clsJoin(
    candidateStatus_SQL.sql(),
    "id",
    `\`${candidateStatus_modelName}.candidateID\``, //`candidateStatus.id`
    candidateStatus_subqueryAlias, //tempCandidateStatuss
    "INNER"
  );

  if (candidateStatus_filtered) {
    sql.joins.push(candidateStatusJoin);
  }

  //Count should be pre-cursor
  //This part would return the count SQL
  sql.fields = [`COUNT(DISTINCT ${TABLE_NAME}.${PRIMARY_KEY}) AS count`];
  if (filters.length > 0) {
    sql.filter = filters.join(" AND ");
  }
  const countSQL = sql.sql();
  sql.filter = "";

  sql.orderBy = getSort(sort, DEFAULT_SORT_BY, PRIMARY_KEY);
  if (cursor) {
    addCursorFilterToQuery(
      cursor,
      sort,
      sortField,
      PRIMARY_KEY,
      replacements,
      filters,
      TABLE_NAME
    );
  }

  if (filters.length > 0) {
    sql.filter = filters.join(" AND ");
  }

  sql.limit = simpleOnly === "true" ? 0 : parseInt(limit);

  //This part will produce the distinct SQL
  sql.fields = [`${TABLE_NAME}.${PRIMARY_KEY}`];
  sql.groupBy = [PRIMARY_KEY];

  const distinctSQL = sql.sql();

  const distinctJoin = new clsJoin(
    distinctSQL,
    PRIMARY_KEY,
    PRIMARY_KEY,
    "tempDistinct",
    "INNER"
  );

  sql.fields = [];

  //build the sql field name and aliases (aliases are used to destructure the object)
  appendFieldsToSQL(fields, sql, table);

  sql.fields = sql.fields.concat(joinFields);

  /* Insert Join Cancellations here..*/
  //Generated by GetAllRightModelJoinCancellationSnippet
  //Generated by GetRightModelJoinCancellationSnippet - GetRightModelJoinCancellationSnippet
  provider_SQL = getProviderSQL(query, true).sql;
  providerJoin.source = provider_SQL.sql();
  providerJoin.joinType = "LEFT";
  //Generated by GetAllLeftModelJoinCancellationSnippet
  //Generated by GetLeftModelJoinCancellationSnippet - GetLeftModelJoinCancellationSnippet
  candidateStatus_SQL = getCandidateStatusSQL(query, true).sql;
  candidateStatusJoin.source = candidateStatus_SQL.sql();
  candidateStatusJoin.joinType = "LEFT";

  //Insert joins here LEFT joins e.g. cardCardKeywordJoin, distincJoin or
  //new clsJoin("marvelduel_belongsto", "deck_id", "id", null)
  sql.joins = [
    distinctJoin,
    //Generated by GetAllRightJoinName
    providerJoin, //Generated by GetRightJoinName - GetRightJoinName
    //Generated by GetAllLeftJoinName
    candidateStatusJoin, //Generated by GetLeftJoinName - GetLeftJoinName
  ];
  resetSQL(sql);

  const sqlString: string = sql.sql();

  return {
    sqlString,
    countSQL,
    replacements,
  };
}

//Generated by GetAllGetmodelsqlChildNext13
//Generated by GetRightModelgetModelSQLSnippet - GetRightModelgetModelSQLSnippet
function getProviderSQL(
  query: Partial<CandidateSearchParams>,
  dontFilter: boolean = false
) {
  const table = "providers";
  const fields: (string | [string, string])[] =
    //Generated by GenerateSQLFieldList
    ["slug", "id", "name"];
  const fieldAliases: string[] = [];
  const modelName = "Provider";
  let filtered = false;
  let replacements: Record<string, string> = {};

  let sql = new clsSQL();
  sql.source = table;

  //build the sql field name and aliases (aliases are used to destructure the object)
  processFields(fields, modelName, table, fieldAliases, sql);

  const filters: string[] = [];
  //Generated by GenerateSeqModelFilters

  /*INSERT JOINS HERE*/

  if (filters.length > 0) {
    filtered = true;
    sql.filter = filters.join(" AND ");
  }

  return {
    sql,
    fieldAliases,
    replacements,
    subqueryAlias: "tempProvider",
    modelName,
    filtered,
  };
}

//Generated by GetAllGetmodelsqlLeftModelChildNext13
//Generated by GetGetmodelsqlLeftModelChildNext13 - GetGetmodelsqlLeftModelChildNext13
function getCandidateStatusSQL(
  query: Partial<CandidateSearchParams>,
  dontFilter: boolean = false
) {
  const table = "candidate_status";
  const fields: (string | [string, string])[] =
    //Generated by GenerateSQLFieldList
    ["id", ["candidate_id", "candidateID"], ["status_id", "statusID"]];
  const fieldAliases: string[] = [];
  const modelName = "CandidateStatus";
  let filtered = false;
  let replacements: Record<string, string> = {};

  let sql = new clsSQL();
  sql.source = table;

  //build the sql field name and aliases (aliases are used to destructure the object)
  processFields(fields, modelName, table, fieldAliases, sql);

  const filters: string[] = [];

  //Generated by GenerateSeqModelFilters

  /*INSERT JOINS HERE*/

  if (filters.length > 0) {
    filtered = true;
    sql.filter = filters.join(" AND ");
  }

  return {
    sql,
    fieldAliases,
    replacements,
    subqueryAlias: "tempCandidateStatus",
    modelName,
    filtered,
  };
}

//Generated by GetSqlModelsGetRoute - GET Models route
export const GET = async (req: Request) => {
  const searchParams = new URL(req.url).searchParams;
  const query = parseParams(searchParams) as Partial<CandidateSearchParams>;

  const candidateAttributes = getMappedKeys(COLUMNS);

  const fetchCount = query["fetchCount"] === "true";
  const sort = getSortedValue(
    query["sort"]
      ? `${query["sort"].includes("-") ? "-" : ""}${getDatabaseFieldName(
          query["sort"],
          COLUMNS
        )}`
      : undefined,
    candidateAttributes,
    DEFAULT_SORT_BY
  );

  //Remove the - from the sort parameter
  const sortField = sort.includes("-") ? sort.substring(1) : sort;
  const cursorField = getColumnKeyByDbName(sortField, COLUMNS);

  let { sqlString, countSQL, replacements } = getCandidateSQL(query);

  let recordCount;
  if (fetchCount) {
    const countResult: any = await sequelize.query(countSQL, {
      replacements,
      type: QueryTypes.SELECT,
    });

    recordCount = countResult[0].count;
  }

  let data: CandidateModel[] = await sequelize.query(sqlString, {
    replacements,
    type: QueryTypes.SELECT,
    nest: true,
  });

  let cursor = "";

  if (data && data.length > 0) {
    cursor = getCursorString(cursorField, PRIMARY_KEY, data);
  }

  //Add any object that will be turned into an array
  //e.g. const result = reduceResult(result as any, [["CardCardKeyword", "CardCardKeywords"],]);
  data = reduceResult(data as any, [
    //Generated by GetAllLeftModelsToReduce
    ["CandidateStatus", "CandidateStatus"], //Generated by GetLeftModelToReduce - GetLeftModelToReduce
  ]) as unknown as CandidateModel[];

  //Generated by GetAllLeftModelReduceResultAndRemoveDuplicates
  //Generated by GetLeftModelReduceResultAndRemoveDuplicates - GetLeftModelReduceResultAndRemoveDuplicates
  removeDuplicates(data as any, "CandidateStatus", "id");

  return NextResponse.json({
    rows: data,
    cursor,
    ...(fetchCount && { count: recordCount }),
  });
};

//Generated by GetSingleCreateModelPOSTRoute - GetSingleCreateModelPOSTRoute
export const POST = async (req: Request) => {
  const res = (await req.json()) as CandidateFormUpdatePayload;

  try {
    await CandidateSchema.validate(res);
  } catch (error) {
    return handleSequelizeError(error);
  }

  const t = await sequelize.transaction();

  try {
    const newCandidate = await createCandidate(res, t);
    const id = newCandidate[PRIMARY_KEY];

    //Generated by GetAllSimpleModelInserts
    //Generated by GetSimpleModelInserts - GetSimpleModelInserts
    const { newStatus } = res;
    const CandidateStatus = [];

    for (const item of newStatus) {
      const newCandidateStatus = await createCandidateStatus(
        {
          candidateID: newCandidate.id,
          statusID: item,
        },
        t
      );

      CandidateStatus.push({
        statusID: item,
        id: newCandidateStatus.id,
      });
    }

    await t.commit();

    return NextResponse.json({
      status: "success",
      id,

      //Generated by GetAllSimplePluralizedModelName
      CandidateStatus, //Generated by GetSimplePluralizedModelName - GetSimplePluralizedModelName
    });
  } catch (err) {
    await t.rollback();
    return handleSequelizeError(err);
  }
};

export const DELETE = async (req: Request) => {
  const body = (await req.json()) as CandidateDeletePayload;
  const { deletedCandidates } = body;

  if (deletedCandidates.length > 0) {
    const t = await sequelize.transaction();
    try {
      await deleteCandidates(PRIMARY_KEY, deletedCandidates, t);
      t.commit();
      return NextResponse.json("success");
    } catch (error) {
      t.rollback();
      return handleSequelizeError(error);
    }
  }
};
